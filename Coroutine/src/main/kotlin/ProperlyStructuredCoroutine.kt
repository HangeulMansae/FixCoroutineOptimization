package org.example

import kotlinx.coroutines.*

// 병렬 작업하기
fun main(): Unit = runBlocking{
    val list = listOf(
        listOf("작업 1", "작업 1-1", "작업 1-2", "작업 1-3", "작업 1-4", "작업 1-5"),
        listOf("작업 2", "작업 2-1", "작업 2-2", "작업 2-3", "작업 2-4", "작업 2-5"),
        listOf("작업 3", "작업 3-1", "작업 3-2", "작업 3-3", "작업 3-4", "작업 3-5"),
        listOf("작업 4", "작업 4-1", "작업 4-2", "작업 4-3", "작업 4-4", "작업 4-5"),
        listOf("작업 5", "작업 5-1", "작업 5-2", "작업 5-3", "작업 5-4", "작업 5-5"),
        listOf("작업 6", "작업 6-1", "작업 6-2", "작업 6-3", "작업 6-4", "작업 6-5"),
        listOf("작업 7", "작업 7-1", "작업 7-2", "작업 7-3", "작업 7-4", "작업 7-5"),
        listOf("작업 8", "작업 8-1", "작업 8-2", "작업 8-3", "작업 8-4", "작업 8-5"),
        listOf("작업 9", "작업 9-1", "작업 9-2", "작업 9-3", "작업 9-4", "작업 9-5"),
        listOf("작업 10", "작업 10-1", "작업 10-2", "작업 10-3", "작업 10-4", "작업 10-5"),
        listOf("작업 11", "작업 11-1", "작업 11-2", "작업 11-3", "작업 11-4", "작업 11-5"),
        listOf("작업 12", "작업 12-1", "작업 12-2", "작업 12-3", "작업 12-4", "작업 12-5"),
        listOf("작업 13", "작업 13-1", "작업 13-2", "작업 13-3", "작업 13-4", "작업 13-5"),
        listOf("작업 14", "작업 14-1", "작업 14-2", "작업 14-3", "작업 14-4", "작업 14-5"),
        listOf("작업 15", "작업 15-1", "작업 15-2", "작업 15-3", "작업 15-4", "작업 15-5"),
        listOf("작업 16", "작업 16-1", "작업 16-2", "작업 16-3", "작업 16-4", "작업 16-5"),
        listOf("작업 17", "작업 17-1", "작업 17-2", "작업 17-3", "작업 17-4", "작업 17-5"),
        listOf("작업 18", "작업 18-1", "작업 18-2", "작업 18-3", "작업 18-4", "작업 18-5"),
        listOf("작업 19", "작업 19-1", "작업 19-2", "작업 19-3", "작업 19-4", "작업 19-5"),
        listOf("작업 20", "작업 20-1", "작업 20-2", "작업 20-3", "작업 20-4", "작업 20-5"),
    )
    withContext(Dispatchers.IO){
        list.chunked(5).map {
            val task = launch {
                it.forEach {
                    launch {
                        launch {
                            println(it[1])
                        }
                        launch {
                            println(it[2])
                        }
                        launch {
                            println(it[3])
                        }
                        launch {
                            println(it[4])
                        }
                        launch {
                            println(it[5])
                        }
                        // 오히려 아래의 joinAll 작업은 다른 데이터들과 세부 작업 간에 의존성이 없으므로,
                        // 불필요한 기다림이다.
                        // 이게 있으면 n번 데이터의 세부 작업이 모두 끝날 때까지 n+1번의 forEach문으로 넘어가지 못하며,
                        // 동시성이 떨어진다.
                        //joinAll(task1, task2, task3, task4, task5)
                    }
                }
            }
            // 이렇게 해서 5개의 데이터에 대해 각 세부작업이 모두 완료될 때까지,
            // map이 다음 인덱스로 넘어가지 않도록 한다.
            task.join()
        }
    }
}